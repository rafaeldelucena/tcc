\section{An\'alise Funcional}
\subsection{Limita\c{c}\~oes Funcionais}
\afazer{em desenvolvimento}

Atualmente a aplica\c{c}\~ao cliente n\~ao possui uma implementa\c{c}\~ao segura do procotolo CoAP, que utiliza o DTLS.
Para resolver este problema \'e necess\'ario que o pacote seja criptografado.

\section{An\'alise Estrutural}

Fator muito importante para verificar a implemenca\c{c}\~ao de protocolo \'e a interoperabilidade entre diferentes implementa\c{c}\~oes.

A ETSI em conjunto com a IPSO desenvolveram um conjunto de testes para validar o comportamento entre diversas implementa\c{c}\~oes CoAP. Este teste foi aplicado em 24, 25 de mar\c{c}o de 2012 em Paris, conhecido como primeiro evento IOT CoAP plugtest.  Os pontos principais objetivos do teste s\~ao:

    \begin{itemize}
        \item Especifica\c{c}\~ao b\'asica do CoAP.
        \item Transfer\^encia em bloco
        \item Observa\c{c}\~ao de recursos CoAP.
        \item Formato CORE link.
    \end{itemize}

O teste basicamente \'e executado entre diferentes dispositivos e implementa\c{c}\~oes CoAP. O cen\'ario inicial de testes \'e composto por:
    \begin{itemize}
        \item Cada equipamento deve estar configurado com um endere\c{c}o unicast.
        \item A cache do cliente deve estar limpa.
        \item Utiliza\c{c}\~ao da op\c{c}\~ao ETag por padr\~ao deve ser evitada a n\~ao ser que esteja explicitamente descrito no caso de teste. 
        \item O uso de Tokens deve ser evitado a n\~ao ser que o caso de teste utilize, por\'em a implementa\c{c}\~ao deve estar preparada para tratar o token.
        \item O uso de repostas por Piggybacked deve ser preferencial, a menos que a descri\c{c}\~ao do teste altere este padr\~ao.
    \end{itemize}

Os testes feitos para o protocolo CoAP s\~ao:
\begin{enumerate}
    \item Cumprir transa\c{c}\~oes GET, confirm\'avel.
    \item Cumprir transa\c{c}\~oes POST, confirm\'avel.
    \item Cumprir transa\c{c}\~oes PUT, confirm\'avel.
    \item Cumprir transa\c{c}\~oes DELETE, confirm\'avel.
    \item Cumprir transa\c{c}\~oes GET, sem confirma\c{c}\~ao.
    \item Cumprir transa\c{c}\~oes POST, sem confirma\c{c}\~ao.
    \item Cumprir transa\c{c}\~oes PUT, sem confirma\c{c}\~ao.
    \item Cumprir transa\c{c}\~oes DELETE, sem confirma\c{c}\~ao. 
    \item Cumprir transa\c{c}\~oes GET com resposta separada.
    \item Tratar requisic\c{c}\~ao com op\c{c}\~ao de Token.
    \item Tratar requisic\c{c}\~ao sem op\c{c}\~ao de Token.
    \item Tratar requisic\c{c}\~ao contento v\'arias opc\c{c}\~oes URI-Path.
    \item Tratar requisic\c{c}\~ao contento v\'arias opc\c{c}\~oes URI-Query.
    \item Interoperablidade em contexto de perda de pacotes (CON mode, piggybacked response)
    \item Interoperablidade em contexto de perda de pacotes (CON mode, delayed response)
    \item Cumprir transa\c{c}\~oes GET com resposta separada, sem confirma\c{c}\~ao.
\end{enumerate}

\'E previsto tamb\'em testes para validar o formato de dados CORE link Format. Abaixo os testes:

\begin{enumerate}
    \item Descoberta de recursos utilizando a interface de acesso well-known.
    \item Utiliza\c{c}\~ao de consulta para filtrar resultados.
\end{enumerate}

Testes para validar a transfer\^encia de blocos:
\begin{enumarate}
    \item Tratar a transfer\^encia de blocos para recursos grandes utilizando o m\'etodo GET (negocia\c{c}\~ao antecipada).
    \item Tratar a transfer\^encia de blocos para recursos grandes utilizando o m\'etodo GET (negocia\c{c}\~ao atrasada).
    \item Tratar a transfer\^encia de blocos para recursos grandes utilizando o m\'etodo PUT.
    \item Tratar a transfer\^encia de blocos para recursos grandes utilizando o m\'etodo POST.
\end{enumerate}

Testes para observa\c{c}\~ao de recursos:
\begin{enumerate}
    \item Tratar observa\c{c}\~ao de recursos.
    \item Parar a observa\c{c}\~ao de recursos.
    \item Detec\c{c}\~ao de deregistro do cliente (Max-Age)
    \item Detec\c{c}\~ao de deregistro do servidor (client OFF)
    \item Detec\c{c}\~ao de deregistro do servidor (RESET expl\'icito)
\end{enumarete}

\section{An\'alise de Desempenho}

\afazer{em desenvolvimento: coletando os dados das outras implementa\c{c}\~oes}


O tempo de execu\c{c}\~ao das principais fun\c{c}\~oes foi medido. Abaixo a tabela \ref{comparacaoCoap}, que faz um comparativo com as diversas arquituras e opera\c{c}\~oes entres as principais solu\c{c}\~oes livres.

\begin{table}[h]
\label{comparacaoCoap}
\centering
\begin{tabular}{@{}lllll@{}}
\toprule
App & OS & CoAP & Size &  Memory &  &  \\ \midrule
CoapClient & EPOS &  CantCoap &  &  & & \\
ER-Rest-Example & Contiki &  Erbium &  &  &  \\
Rest-client & Contiki &  libcoap &  &  &  \\
Coap-client & OpenWSN &  OpenCoAP &  &  &  \\ \bottomrule
\end{tabular}
\caption{Compara\c{c}\~ao das implementa\c{c}\~oes}
\end{table}

Abaixo um comparativo entre as principais fun\c{c}\~oes utilizadas nos sistema, utilizando um pacote padr\~ao e um pacote com tamanho m\'aximo de 128 bytes, o valor m\'aximo de MTU utilizado.

\begin{table}[h]
\label{executionTimeCoap}
\centering
\begin{tabular}{@{}lllll@{}}
\toprule
Biblioteca CoAP & Tipo do Pacote & Tempo em ms &  \\ \midrule
CantCoap &  Small &  & \\
CantCoap &  Large &  & \\
Erbium &  Small &  &  \\
Erbium &  Large &  &  \\
OpenCoAP &  Small &  &  \\
OpenCoAP &  Large &  &  \\ \bottomrule
\end{tabular}
\caption{Compara\c{c}\~ao das implementa\c{c}\~oes em tempo de execu\c{c}\~ao}
\end{table}

Tabela que demonstra a vaz\~ao do sistema para mensagens, com tamanho definido anteriormente.

\begin{table}[h]
\label{throughputCoap}
\centering
\begin{tabular}{@{}lllll@{}}
\toprule
Biblioteca CoAP & Tipo do Pacote & N\'umero de mensagens &  \\ \midrule
CantCoap &  Small &  & \\
CantCoap &  Large &  & \\
Erbium &  Small &  &  \\
Erbium &  Large &  &  \\
OpenCoAP &  Small &  &  \\
OpenCoAP &  Large &  &  \\ \bottomrule
\end{tabular}
\caption{Compara\c{c}\~ao da vaz\~ao entre as  implementa\c{c}\~oes}
\end{table}

