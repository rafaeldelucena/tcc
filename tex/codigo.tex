\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{blue},
  identifierstyle=\color{blue!20!black},
  stringstyle=\color{red},
}

\subsection{CoAP}

\begin{lstlisting}

#ifndef __coap_packet_h__
#define __coap_packet_h__

#include <coap_pdu.h>

__BEGIN_SYS

class CoapPacket : public CoapPDU
{
    public:
        static const int ackTimeout = 2000000;
        static const double ackRandomFactor = 1.5;
        static const int maxRetransmit = 4;
        static const int nStart = 1;

        CoapPacket(const UDP_Address & to);
        CoapPacket(const UDP_Address & from, const char * data, unsigned len);
        CoapPacket(CoapPDU * pdu);
        CoapPacket();
        ~CoapPacket();

        bool isConfirmable();
        bool isConfirmed();
        bool isFailure() {return false;};
        void setConfirmed();
        void reset();
        virtual void update() {kout << "Packet update" << endl;};
        UDP_Address remote() const;
        int getToken();
    protected:
        void generateNewToken(unsigned int len);
    private:
        static const int _maxPDUSize = 100;
        bool _isConfirmed;
        UDP_Address _remote;
        u8 _pduBuffer[_maxPDUSize];
        Alarm * _alarm;
};

class CoapACK : public CoapPacket
{
    public:
        CoapACK(int id) : CoapPacket() {
            setType(CoapPacket::COAP_ACKNOWLEDGEMENT);
            setCode(CoapPacket::COAP_EMPTY);
            setMessageID(id);
        }
};

class CoapConfirmable : public CoapPacket {
    public:
        CoapConfirmable(CoapPacket::Code code);
        ~CoapConfirmable();
        void update();
        bool isFailure();
        void reset();
    private:
        Alarm * _alarm;
        int _retransmissionCounter;
        int _timeout;
};

__END_SYS

#endif /*__coap_packet_h__*/


#ifndef __coap_request_h__
#define __coap_request_h__

#include <coap_packet.h>

__BEGIN_SYS

class CoapRequest : public CoapConfirmable
{
    public:
        CoapRequest(CoapPacket::Code code, const char* uri);
        virtual void onSuccess();
        virtual void onError();
        static void incomingResponse(CoapPacket * packet);
        bool wasAnswered() { return (_response != 0);}
    private:
        void addResponse(CoapPacket *);
        void addAsPending();
        static CoapRequest * removePendingByToken(int token);
        static unsigned int indexByToken(int token);
        static const int _maxPDUSize = 100;
        static const int _maxPending = 100;
        char _uriBuffer[_maxPDUSize];
        int _uriSize;
        static CoapRequest * _pendingRequests[_maxPending];
        CoapPacket * _response;
};

__END_SYS

#endif /*__coap_request_h__*/


#ifndef __coap_response_h__
#define __coap_response_h__

__BEGIN_SYS

class CoapPacket;

template <class T>
class CoapResponse : public CoapPacket
{
    public:
        CoapResponse(T data, CoapRequest * r);
        ~CoapResponse();
    private:
        T * _data;
};

__END_SYS

#endif /*__coap_response_h__*/


#ifndef __coap_socket_h_
#define __coap_socket_h_

#include <udp.h>
#include <coap_packet.h>
#include <utility/queue.h>

#define COAP_PORT 5683

__BEGIN_SYS

class CoapSocket : public UDP::Socket
{
public:
    CoapSocket(const UDP_Address & local);
    ~CoapSocket();
    void sendPacket(CoapPacket * pdu);
    void sendPacket(const CoapPacket & pdu);
    void received(const UDP_Address & from, const char* msg, unsigned int len);
};

__END_SYS

#endif /* __coap_socket_h_ */


#include <coap_packet.h> 
#include <coap_socket.h>
#include <utility/handler.h>
__BEGIN_SYS

class CoapTransport
{
    public:
    static Function_Handler * dispatcher();
    static void incoming(CoapPacket * in);
    static void outgoing(CoapPacket * out);
    
    private:
    CoapTransport();
    ~CoapTransport();
    void addNonConfirmed(CoapPacket* p);
    static void dispatch();
    CoapSocket * _socket;
    Queue<CoapPacket> * _queue;
    Function_Handler * _handler;
    static CoapTransport * getInstance();
    static CoapTransport * _instance;
};
__END_SYS


#include <utility/random.h>
#include <utility/string.h>
#include <coap_packet.h>
#include <coap_transport.h>

__BEGIN_SYS

/*
 * For a new Confirmable message, the initial timeout is set
 * to a random duration (often not an integral number of seconds)
 * between ACK_TIMEOUT and (ACK_TIMEOUT * ACK_RANDOM_FACTOR) (see
 * Section 4.8)
 * */
CoapPacket::CoapPacket(const UDP_Address & to) : CoapPDU(_pduBuffer, _maxPDUSize, 4),
     _remote(to)
{
    setVersion(1);
    _isConfirmed = false;
    int range = (CoapPacket::ackTimeout * CoapPacket::ackRandomFactor) - CoapPacket::ackTimeout;
    int rand = Pseudo_Random::random() % range;
    setMessageID(rand);
}

CoapPacket::CoapPacket() : CoapPDU(_pduBuffer, _maxPDUSize, 4), _remote(UDP_Address("10.0.2.15:5863"))
{
    setVersion(1);
    _isConfirmed = false;
    int range = (CoapPacket::ackTimeout * CoapPacket::ackRandomFactor) - CoapPacket::ackTimeout;
    int rand = Pseudo_Random::random() % range;
    setMessageID(rand);
}

CoapPacket::CoapPacket(const UDP_Address & from, const char * data, unsigned len) : CoapPDU(_pduBuffer, _maxPDUSize, len),
    _remote(from)
{
    strncpy((char*)_pduBuffer, data, len);
}

CoapPacket::CoapPacket(CoapPDU * pdu) : CoapPDU(pdu->getPDUPointer(), _maxPDUSize, pdu->getPDULength()),
    _remote(UDP_Address("10.0.2.15:5863"))
{
    setMessageID(pdu->getMessageID());
}

void CoapPacket::reset()
{
    CoapPDU::reset();
    _isConfirmed = false;
}

int CoapPacket::getToken()
{
    return atol((char*)getTokenPointer());
}

CoapPacket::~CoapPacket()
{
}

CoapConfirmable::~CoapConfirmable()
{
    if (_alarm) delete _alarm;
    _alarm = 0;
}


void CoapConfirmable::reset()
{
    CoapPacket::reset();
    if (_alarm) delete _alarm;
    _alarm = 0;
}

void CoapPacket::setConfirmed()
{
    _isConfirmed = true;
}

bool CoapPacket::isConfirmed()
{
    return _isConfirmed;
}

UDP_Address CoapPacket::remote() const
{
    return _remote;
}

bool CoapPacket::isConfirmable()
{
    return (getType() == CoapPacket::COAP_CONFIRMABLE);
}

void CoapPacket::generateNewToken(unsigned int len)
{
    if (len > 4) return;
    kout << "size of token: " << len << endl;
    int range = 0xFF << len;
    kout << "range:" << range << endl;
    int rand = Pseudo_Random::random() % range;
    kout << "random:" << rand << endl;
    static const int size = 20;
    char buf[size];
    itoa(rand, buf);
    setToken((u8*)buf, len);
}

void CoapConfirmable::update()
{
    kout << "Confirmable update" << endl;
    if (!isConfirmable()) return;
    _retransmissionCounter++;
    _timeout = _timeout * 2;
    if (_alarm) delete _alarm;
    if (isConfirmed()) {
        kout << "already confirmed!" << endl;
        return;
    }
    kout << "configure new alarm with " << _timeout << endl;
    _alarm = new Alarm(_timeout, CoapTransport::dispatcher(), 1);
}

bool CoapConfirmable::isFailure()
{
    return (_retransmissionCounter > CoapPacket::maxRetransmit);
}
        
CoapConfirmable::CoapConfirmable(CoapPacket::Code code) : CoapPacket() {
    setType(CoapPacket::COAP_CONFIRMABLE);
    setCode(code);
    int range = (CoapPacket::ackTimeout * CoapPacket::ackRandomFactor) - CoapPacket::ackTimeout;
    int rand = Pseudo_Random::random() % range;
    _timeout = CoapPacket::ackTimeout + rand;
    _retransmissionCounter = 0;
    _alarm = 0;
}


__END_SYS


#include <system/config.h>
#include <coap_request.h>
#include <coap_transport.h>

__BEGIN_SYS

CoapRequest * CoapRequest::_pendingRequests[] = {0};

CoapRequest::CoapRequest(CoapPacket::Code code, const char* uri)
    : CoapConfirmable(code)
{
    _uriSize = strlen(uri);
    strncpy(_uriBuffer, uri, _uriSize);
    generateNewToken(4);
    setURI(_uriBuffer, _uriSize);
    CoapTransport::outgoing(this);
    addAsPending();
}

void CoapRequest::incomingResponse(CoapPacket * packet)
{
    CoapRequest * req = removePendingByToken(packet->getToken());
    if (req) req->addResponse(packet);
}

void CoapRequest::addResponse(CoapPacket * packet)
{
    if (packet->isFailure()) {
        onError();
    } else {
        onSuccess();
        _response = packet;
    }
}

void CoapRequest::addAsPending()
{
    unsigned int index = indexByToken(getToken());
    CoapRequest::_pendingRequests[index] = this;
}

unsigned int CoapRequest::indexByToken(int token)
{
    return token % CoapRequest::_maxPending;
}

CoapRequest * CoapRequest::removePendingByToken(int token)
{
    unsigned int index = indexByToken(token);
    CoapRequest * ptr = CoapRequest::_pendingRequests[index];
    CoapRequest::_pendingRequests[index] = 0;
    return ptr;
}

void CoapRequest::onSuccess()
{
    kout << "success!" << endl;
}

void CoapRequest::onError()
{
    kout << "error!" << endl;
}

__END_SYS


#include <alarm.h>
#include <utility/handler.h>
#include <utility/list.h>
#include <udp.h>
#include <coap_request.h>
#include <coap_transport.h>

__BEGIN_SYS

static const int idsSize = 1000;
static int ids[idsSize] = {0};

CoapTransport * CoapTransport::_instance = 0; 

static void updateIds(int id) {
    int pos = id % idsSize;
    ids[pos] = id;
}

static bool checkId(int id) {
    int pos = id % idsSize;
    return (ids[pos] == id);
}

CoapTransport * CoapTransport::getInstance()
{
    if (CoapTransport::_instance == 0) {
        CoapTransport::_instance = new CoapTransport();
    }
    return CoapTransport::_instance;
}

CoapTransport::CoapTransport()
{
    _handler = new Function_Handler(CoapTransport::dispatch);
    _queue = new Queue<CoapPacket>();
    _socket = new CoapSocket(UDP_Address(IP::instance()->address(), COAP_PORT));
}

void CoapTransport::dispatch()
{
    CoapTransport * t = CoapTransport::getInstance();
    if (!t) return;
    Queue<CoapPacket>::Element * e = t->_queue->remove();
    CoapPacket * p = e->object();
    if (!p) return;
    if (p->isFailure()){
        kout << "failure "<< endl;
        if (e) delete e;
        return;
    }
    outgoing(p);
    if (e) delete e;
}

void CoapTransport::addNonConfirmed(CoapPacket * p)
{
    Queue<CoapPacket>::Element * e = new Queue<CoapPacket>::Element(p);
    _queue->insert(e);
}

CoapTransport::~CoapTransport()
{
    delete _handler;
    delete _socket;
    delete[] _queue;
}

void CoapTransport::incoming(CoapPacket * in) {
    if (!in) return;
    CoapTransport * t = CoapTransport::getInstance();
    if (!t) return;
    kout << "INCOMING packet" << endl;
    in->print();
    if (in->getType() == CoapPacket::COAP_ACKNOWLEDGEMENT) {
        kout << "is ACK!" << endl;
        updateIds(in->getMessageID());
    }
    if (in->getType() >= CoapPacket::COAP_CREATED) {
        kout << "is a Response!" << endl;
        CoapRequest::incomingResponse(in);
    }
}

void CoapTransport::outgoing(CoapPacket * out)
{
    if (!out) return;
    kout << "OUTGOING packet" << endl;
    kout << "-------------------------" << endl;
    out->print();
    kout << "-------------------------" << endl;
    CoapTransport * t = CoapTransport::getInstance();
    if (!t) return;
    t->_socket->sendPacket(out);
    if (out->isConfirmable()) {
        kout << "Is confirmable!" << endl;
        if (checkId(out->getMessageID())) {
            kout << "is confirmed!" << endl;
            return;
        }
        t->addNonConfirmed(out);
        out->update();
    }
}

Function_Handler * CoapTransport::dispatcher()
{
    CoapTransport * t = CoapTransport::getInstance();
    if (!t) return 0;
    return _instance->_handler;
}

__END_SYS


#include <coap_transport.h>
#include <coap_socket.h>

__BEGIN_SYS

CoapSocket::CoapSocket(const UDP_Address & local) : UDP::Socket(local, UDP::Address(Traits<IP>::BROADCAST, COAP_PORT))
{
}

CoapSocket::~CoapSocket()
{
}

void CoapSocket::received(const UDP_Address& from, const char* data, unsigned int len)
{
	CoapPacket *packet = new CoapPacket(from, data, len);

	if(!packet->validate()) return;
	
	packet->print();

	if (packet->getType() == CoapPacket::COAP_ACKNOWLEDGEMENT) {
	    kout << "is ack!" << endl;
    }

    CoapTransport::incoming(packet);
}

void CoapSocket::sendPacket(CoapPacket * pdu)
{
    if (!pdu) return;
    remote(pdu->remote());
    send(reinterpret_cast<char*>(pdu->getPDUPointer()), pdu->getPDULength());
}

__END_SYS
\end{lstlisting}


\subsection{Aplica\c{c}\~ao WEB}
